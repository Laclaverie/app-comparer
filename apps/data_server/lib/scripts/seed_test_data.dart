import 'dart:io';
import 'package:drift/drift.dart';
import '../data_database.dart';

class TestDataSeeder {
  final DataDatabase database;

  TestDataSeeder(this.database);

  Future<void> seedTestProducts() async {
    print('üå± G√©n√©ration des produits de test...');

    final testProducts = [
      ProductsCompanion(
        barcode: const Value(1234567890),
        name: const Value('Coca-Cola 33cl'),
        description: const Value('Boisson gazeuse'),
        imageFileName: const Value('coca_cola.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(2345678901),
        name: const Value('Pain de mie Harrys'),
        description: const Value('Pain de mie complet 500g'),
        imageFileName: const Value('pain_harrys.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(3456789012),
        name: const Value('Lait Lactel 1L'),
        description: const Value('Lait demi-√©cr√©m√© UHT'),
        imageFileName: const Value('lait_lactel.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(4567890123),
        name: const Value('Bananes Bio 1kg'),
        description: const Value('Bananes biologiques'),
        imageFileName: const Value('bananes_bio.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(5678901234),
        name: const Value('Yaourt Danone x8'),
        description: const Value('Yaourts nature sucr√©s'),
        imageFileName: const Value('yaourt_danone.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(6789012345),
        name: const Value('P√¢tes Barilla 500g'),
        description: const Value('P√¢tes penne rigate'),
        imageFileName: const Value('pates_barilla.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(7890123456),
        name: const Value('Huile d\'olive Puget'),
        description: const Value('Huile d\'olive vierge extra 50cl'),
        imageFileName: const Value('huile_puget.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(8901234567),
        name: const Value('Riz Uncle Ben\'s 1kg'),
        description: const Value('Riz long grain √©tuv√©'),
        imageFileName: const Value('riz_uncle_bens.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(9012345678),
        name: const Value('Fromage Emmental 200g'),
        description: const Value('Emmental fran√ßais AOP'),
        imageFileName: const Value('emmental.jpg'),
      ),
      ProductsCompanion(
        barcode: const Value(1122334455),
        name: const Value('Chocolat Milka Oreo'),
        description: const Value('Chocolat au lait avec biscuits Oreo'),
        imageFileName: const Value('milka_oreo.jpg'),
      ),
    ];

    for (final product in testProducts) {
      try {
        // V√©rifier si le produit existe d√©j√†
        final existing = await database.getProductByBarcode(product.barcode.value);
        if (existing == null) {
          await database.insertProduct(product);
          print('‚úÖ Produit ajout√©: ${product.name.value}');
        } else {
          print('‚ö†Ô∏è  Produit existe d√©j√†: ${product.name.value}');
        }
      } catch (e) {
        print('‚ùå Erreur pour ${product.name.value}: $e');
      }
    }

    print('üéâ G√©n√©ration termin√©e !');
  }

  Future<void> clearTestData() async {
    print('üßπ Suppression des donn√©es de test...');
    
    // Supprimer tous les produits
    await (database.delete(database.products)).go();
    
    print('‚úÖ Donn√©es supprim√©es !');
  }

  Future<void> showStats() async {
    final count = await database.select(database.products).get().then((rows) => rows.length);
    print('üìä Nombre de produits en base: $count');
  }

  Future<void> seedTestStores() async {
    print('üè™ G√©n√©ration des magasins de test...');

    final testStores = [
      SupermarketsCompanion(
        name: const Value('Carrefour'),
        location: const Value('123 Rue de la R√©publique, Centre Commercial'),
      ),
      SupermarketsCompanion(
        name: const Value('Leclerc'),
        location: const Value('456 Avenue des Champs, Zone Commerciale Nord'),
      ),
      SupermarketsCompanion(
        name: const Value('Monoprix'),
        location: const Value('789 Place du March√©, Centre Ville'),
      ),
      SupermarketsCompanion(
        name: const Value('Super U'),
        location: const Value('321 Boulevard de la Gare, Quartier Sud'),
      ),
      SupermarketsCompanion(
        name: const Value('IGA'),
        location: const Value('654 Rue des Entreprises, Zone Industrielle'),
      ),
    ];

    for (final store in testStores) {
      try {
        await database.into(database.supermarkets).insert(store);
        print('‚úÖ Magasin ajout√©: ${store.name.value} - ${store.location.value}');
      } catch (e) {
        print('‚ö†Ô∏è  Magasin existe d√©j√†: ${store.name.value}');
      }
    }
  }

  Future<void> seedTestPrices() async {
    print('üí∞ G√©n√©ration des prix de test...');

    // R√©cup√©rer les produits et magasins existants
    final products = await database.select(database.products).get();
    final stores = await database.select(database.supermarkets).get();

    if (products.isEmpty || stores.isEmpty) {
      print('‚ùå Pas de produits ou magasins trouv√©s. G√©n√©rez-les d\'abord.');
      return;
    }

    // G√©n√©rer des prix pour les 3 premiers produits dans tous les magasins
    for (int i = 0; i < 3 && i < products.length; i++) {
      final product = products[i];
      final basePrice = 2.0 + (i * 0.5); // Prix de base variable

      for (final store in stores) {
        // Variation de prix par magasin (-20% √† +30%)
        final variation = (store.id % 5 - 2) * 0.1; // -0.2 √† +0.3
        final price = basePrice + (basePrice * variation);

        final priceEntry = PriceHistoryCompanion(
          productId: Value(product.id),
          supermarketId: Value(store.id),
          price: Value(price),
          date: Value(DateTime.now()),
        );

        try {
          await database.into(database.priceHistory).insert(priceEntry);
          print('‚úÖ Prix ajout√©: ${product.name} chez ${store.name} = ‚Ç¨${price.toStringAsFixed(2)}');
        } catch (e) {
          print('‚ö†Ô∏è  Prix existe d√©j√† pour ${product.name} chez ${store.name}');
        }
      }
    }
  }

  Future<void> seedRealProductPrices() async {
    print('üí∞ Ajout de prix pour les produits scann√©s...');

    // ‚úÖ D'abord lister tous les produits pour voir ce qu'on a
    print('üîç Produits disponibles:');
    final allProducts = await database.select(database.products).get();
    for (final product in allProducts) {
      print('   - ${product.name} (barcode: ${product.barcode})');
    }

    // ‚úÖ Chercher le produit par nom plut√¥t que par barcode
    final chipsProduct = await (database.select(database.products)
        ..where((p) => p.name.like('%chips%') | 
                      p.name.like('%Chips%') |
                      p.description.like('%chips%')))
        .getSingleOrNull();

    if (chipsProduct == null) {
      print('‚ùå Aucun produit chips trouv√©. Ajoutez-le d\'abord depuis votre app !');
      return;
    }

    // R√©cup√©rer tous les magasins
    final stores = await database.select(database.supermarkets).get();
    
    if (stores.isEmpty) {
      print('‚ùå Aucun magasin trouv√©. G√©n√©rez les magasins d\'abord !');
      return;
    }

    print('üçü G√©n√©ration des prix pour: ${chipsProduct.name}');

    // Prix r√©alistes pour un paquet de chips (base: ‚Ç¨2.50)
    final basePriceChips = 2.50;
    
    final storeVariations = {
      'Carrefour': -0.30,    // ‚Ç¨2.20 - moins cher
      'Leclerc': -0.10,      // ‚Ç¨2.40 - l√©g√®rement moins cher
      'Monoprix': 0.40,      // ‚Ç¨2.90 - plus cher (centre ville)
      'Super U': -0.20,      // ‚Ç¨2.30 - competitive
      'IGA': 0.15,           // ‚Ç¨2.65 - l√©g√®rement plus cher
    };

    for (final store in stores) {
      final variation = storeVariations[store.name] ?? 0.0;
      final finalPrice = basePriceChips + variation;
      
      // Ajouter un peu de randomness pour simuler des promos
      final random = (DateTime.now().millisecond % 100) / 1000;
      final adjustedPrice = finalPrice + (random - 0.05);
      
      final priceEntry = PriceHistoryCompanion(
        productId: Value(chipsProduct.id),
        supermarketId: Value(store.id),
        price: Value(double.parse(adjustedPrice.toStringAsFixed(2))),
        date: Value(DateTime.now().subtract(  // ‚úÖ dateRecorded pas date
          Duration(hours: store.id % 24)
        )),
      );

      try {
        await database.into(database.priceHistory).insert(priceEntry);
        print('‚úÖ Prix ajout√©: ${chipsProduct.name} chez ${store.name} = ‚Ç¨${adjustedPrice.toStringAsFixed(2)}');
      } catch (e) {
        // Mettre √† jour si existe d√©j√†
        await (database.update(database.priceHistory)
          ..where((p) => p.productId.equals(chipsProduct.id) & 
                        p.supermarketId.equals(store.id)))
          .write(PriceHistoryCompanion(
            price: Value(adjustedPrice),
            date: Value(DateTime.now()),  // ‚úÖ dateRecorded pas date
          ));
        print('üîÑ Prix mis √† jour: ${chipsProduct.name} chez ${store.name} = ‚Ç¨${adjustedPrice.toStringAsFixed(2)}');
      }
    }
  }

  Future<void> seedPriceHistory() async {
    print('üìà G√©n√©ration de l\'historique des prix...');

    // R√©cup√©rer tous les produits qui ont d√©j√† des prix
    final productsWithPrices = await database
        .select(database.priceHistory)
        .join([innerJoin(database.products, 
            database.products.id.equalsExp(database.priceHistory.productId))])
        .get();

    if (productsWithPrices.isEmpty) {
      print('‚ùå Aucun prix existant. G√©n√©rez d\'abord les prix actuels !');
      return;
    }

    // Grouper par produit
    final productIds = productsWithPrices
        .map((row) => row.readTable(database.priceHistory).productId)
        .toSet();

    for (final productId in productIds) {
      await _generatePriceHistoryForProduct(productId);
    }

    print('‚úÖ Historique des prix g√©n√©r√© pour ${productIds.length} produits');
  }

  Future<void> _generatePriceHistoryForProduct(int productId) async {
    // R√©cup√©rer les prix actuels pour ce produit
    final currentPrices = await (database.select(database.priceHistory)
        ..where((p) => p.productId.equals(productId))).get();

    // R√©cup√©rer le nom du produit pour les logs
    final product = await (database.select(database.products)
        ..where((p) => p.id.equals(productId))).getSingle();

    print('üìä G√©n√©ration historique pour: ${product.name}');

    // ‚úÖ G√©n√©rer 1 prix par jour pour chaque magasin sur 30 jours
    for (int daysAgo = 30; daysAgo > 0; daysAgo--) {
      final date = DateTime.now().subtract(Duration(days: daysAgo));
      
      for (final currentPrice in currentPrices) {
        // ‚úÖ V√©rifier qu'on n'a pas d√©j√† un prix pour ce jour
        final existingPrice = await (database.select(database.priceHistory)
            ..where((p) => p.productId.equals(productId) & 
                          p.supermarketId.equals(currentPrice.supermarketId) &
                          p.date.isBiggerOrEqualValue(DateTime(date.year, date.month, date.day)) &
                          p.date.isSmallerThanValue(DateTime(date.year, date.month, date.day + 1))))
            .getSingleOrNull();
        
        if (existingPrice != null) {
          continue; // Skip si on a d√©j√† un prix pour ce jour
        }
        
        // Cr√©er des variations r√©alistes
        final basePrice = currentPrice.price;
        
        // Tendance g√©n√©rale : l√©g√®re augmentation sur 30 jours
        final trendFactor = 1.0 + (daysAgo * 0.001); // +0.1% par jour plus ancien
        
        // Variations al√©atoires par magasin
        final random = (date.day + currentPrice.supermarketId) % 100;
        final randomFactor = 0.95 + (random / 100 * 0.1); // ¬±5%
        
        // Simuler des promotions occasionnelles
        final isPromotion = (date.day + currentPrice.supermarketId) % 7 == 0;
        final promoFactor = isPromotion ? 0.85 : 1.0; // -15% en promo
        
        final historicalPrice = basePrice * trendFactor * randomFactor * promoFactor;
        
        // ‚úÖ D√©finir une heure fixe dans la journ√©e (14h00)
        final exactDate = DateTime(date.year, date.month, date.day, 14, 0, 0);
        
        final historyEntry = PriceHistoryCompanion(
          productId: Value(productId),
          supermarketId: Value(currentPrice.supermarketId),
          price: Value(double.parse(historicalPrice.toStringAsFixed(2))),
          date: Value(exactDate), // ‚úÖ Heure fixe dans la journ√©e
          isPromotion: Value(isPromotion),
          promotionDescription: isPromotion ? 
              const Value('Promotion hebdomadaire') : 
              const Value.absent(),
        );

        try {
          await database.into(database.priceHistory).insert(historyEntry);
        } catch (e) {
          // Ignorer les doublons
        }
      }
    }
  }

  // Modifiez la m√©thode principale
  Future<void> seedAllData() async {
    await seedTestProducts(); // Produits existants
    await seedTestStores();         // Nouveaux magasins
    await seedTestPrices();         // Nouveaux prix
    
    print('üéâ G√©n√©ration compl√®te termin√©e !');
  }

  // Nouvelle m√©thode pour g√©n√©rer tout
  Future<void> seedAllTestDataWithRealProducts() async {
    await seedTestProducts();     // 10 produits de base
    await seedTestStores();       // 5 magasins
    await seedTestPrices();       // Prix pour les 3 premiers produits de base
    await seedRealProductPrices(); // Prix pour vos produits scann√©s
    
    print('üéâ G√©n√©ration compl√®te termin√©e !');
  }

  // Nouvelle m√©thode pour g√©n√©rer tout avec historique
  Future<void> seedAllTestDataWithHistory() async {
    await seedTestProducts();       // 10 produits de base
    await seedTestStores();         // 5 magasins
    await seedTestPrices();         // Prix actuels pour 3 produits
    await seedRealProductPrices();  // Prix pour produits scann√©s
    await seedPriceHistory();       // ‚Üê Nouveau : historique sur 30 jours
    
    print('üéâ G√©n√©ration compl√®te avec historique termin√©e !');
  }
}

// Script principal
void main(List<String> args) async {
  final database = DataDatabase.development(); // ‚Üê Base de dev persistante
  final seeder = TestDataSeeder(database);

  if (args.contains('--clear')) {
    await seeder.clearTestData();
  } else if (args.contains('--stats')) {
    await seeder.showStats();
  } else if (args.contains('--history')) {
    await seeder.seedPriceHistory(); // Seulement l'historique
  } else if (args.contains('--real-prices')) {
    await seeder.seedRealProductPrices(); // Seulement les prix des produits scann√©s
  } else {
    await seeder.seedAllTestDataWithHistory(); // Tout avec historique
    await seeder.showStats();
  }

  await database.close();
  exit(0);
}